# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: proto/utc_bot.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import AsyncGenerator, Dict, List, Optional

import betterproto
import grpclib


class RequestFailedMessageType(betterproto.Enum):
    PLACE = 0
    MODIFY = 1
    CANCEL = 2


class FillMessageSide(betterproto.Enum):
    BUY = 0
    SELL = 1


class GenericMessageType(betterproto.Enum):
    MESSAGE = 0
    INTERNAL_ERROR = 1
    COMPETITOR_DEACTIVATED = 2
    CHANNEL_REPLACED = 3
    ROUND_ENDED = 4
    RISK_LIMIT_BROKEN = 5


class OrderSpecType(betterproto.Enum):
    MARKET = 0
    LIMIT = 1
    IOC = 2


class OrderSpecSide(betterproto.Enum):
    BID = 0
    ASK = 1


@dataclass
class Credentials(betterproto.Message):
    """Represents the credentials of the competitor"""

    # The username of the competitor
    username: str = betterproto.string_field(1)
    # The password of the competitor
    password: str = betterproto.string_field(2)


@dataclass
class RegisterRequest(betterproto.Message):
    """Represents a request to register a new competitor"""

    # The credentials of the competitor register (struct containing user and pw)
    creds: "Credentials" = betterproto.message_field(1)


@dataclass
class RegisterResponse(betterproto.Message):
    """Represents a response to a request to register a competitor"""

    # Whether the request to register a competitor was successful (false if an
    # error occurred and the competitor was not registered)
    ok: bool = betterproto.bool_field(1)
    # A message detailing why a failure occurred, if it did
    message: str = betterproto.string_field(2)


@dataclass
class AwaitTradingStartRequest(betterproto.Message):
    """Request to await for trading to start"""

    # the credentials of the competitor waiting for the case to start
    creds: "Credentials" = betterproto.message_field(1)


@dataclass
class AwaitTradingStartResponse(betterproto.Message):
    """Response to request to await trading start"""

    # Whether the round has actually started (false if a timeout or internal
    # error occurred)
    started: bool = betterproto.bool_field(1)
    # A message conveying the failure to await if it occurred
    message: str = betterproto.string_field(2)


@dataclass
class StreamMessagesRequest(betterproto.Message):
    """A request to begin streaming of exchange updates"""

    # The credentials of the already registered competitor who wishes to stream
    # updates
    creds: "Credentials" = betterproto.message_field(1)


@dataclass
class RequestFailedMessage(betterproto.Message):
    """
    Response sent when a request to place an order has failed. If this message
    is received, then the request corresponding to the provided order IDs could
    not be completed
    """

    # The type of the failed order that was sent (PLACE = 0, MODIFY = 1, CANCEL =
    # 2)
    type: "RequestFailedMessageType" = betterproto.enum_field(1)
    # The ID of the order that was not successfully placed (or used to replace an
    # old order), if any
    place_order_id: str = betterproto.string_field(2)
    # The ID of the order that was not successfully cancelled (or replaced), if
    # any
    cancel_order_id: str = betterproto.string_field(3)
    # The message associated with the failed request
    message: str = betterproto.string_field(4)
    # Asset code that the request was sent for
    asset: str = betterproto.string_field(5)
    # Timestamp that the failure was noted
    timestamp: str = betterproto.string_field(6)


@dataclass
class PnLMessage(betterproto.Message):
    """An update containing PnL information for the competitor"""

    # The PnL of the competitor
    realized_pnl: str = betterproto.string_field(1)
    # Mark to Market PnL
    m2m_pnl: str = betterproto.string_field(2)
    # The timestamp when this update was created
    timestamp: str = betterproto.string_field(3)


@dataclass
class TradeMessage(betterproto.Message):
    """A message containing info about a recent trade that occurred"""

    # The asset that the trade occurred in
    asset: str = betterproto.string_field(1)
    # The price that the trade occurred at
    price: str = betterproto.string_field(2)
    # The quantity of the trade
    qty: int = betterproto.int32_field(3)
    # The timestamp at which this trade occurred
    timestamp: str = betterproto.string_field(7)


@dataclass
class FillMessage(betterproto.Message):
    """An update containing info about a recent order fill that occurred"""

    # The ID of the order that was filled
    order_id: str = betterproto.string_field(1)
    # The asset that was filled
    asset: str = betterproto.string_field(2)
    # The side that the competitor was on.  If order_side == BUY, then this fill
    # resulted in you buying the asset  If order_side == SELL, then this fill
    # resulted in you selling the asset
    order_side: "FillMessageSide" = betterproto.enum_field(3)
    # The price level that was filled at
    price: str = betterproto.string_field(4)
    # The quantity that was filled
    filled_qty: int = betterproto.int32_field(5)
    # The remaining quantity in the order
    remaining_qty: int = betterproto.int32_field(6)
    # The timestamp at which the fill was processed
    timestamp: str = betterproto.string_field(7)


@dataclass
class MarketSnapshotMessage(betterproto.Message):
    """Update containing information on books for every asset"""

    # map from asset code to book update for that code
    books: Dict[str, "MarketSnapshotMessageBook"] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    # The time at which the market info was found
    timestamp: str = betterproto.string_field(2)


@dataclass
class MarketSnapshotMessageBook(betterproto.Message):
    """Information for individual asset within whole book update"""

    # The asset associated with the book
    asset: str = betterproto.string_field(1)
    # The bid price levels
    bids: List["MarketSnapshotMessageBookPriceLevel"] = betterproto.message_field(2)
    # The ask price levels containing qty and px
    asks: List["MarketSnapshotMessageBookPriceLevel"] = betterproto.message_field(3)


@dataclass
class MarketSnapshotMessageBookPriceLevel(betterproto.Message):
    px: str = betterproto.string_field(1)
    qty: int = betterproto.int32_field(2)


@dataclass
class GenericMessage(betterproto.Message):
    """A misc. event sent through the update stream"""

    # The type of exchange event that was sent through the feed
    event_type: "GenericMessageType" = betterproto.enum_field(1)
    # The message text associated with that event
    message: str = betterproto.string_field(2)


@dataclass
class LiquidationMessage(betterproto.Message):
    """Response containing status of order request"""

    # The message associated with the liquidation
    message: str = betterproto.string_field(1)
    # The order ID associated with the market order (so they can match fill to
    # risk violation)
    order_id: str = betterproto.string_field(2)
    # Asset code of order
    asset: str = betterproto.string_field(3)
    # Timestamp that market order was *initiated*
    timestamp: str = betterproto.string_field(4)


@dataclass
class OrderCancelledMessage(betterproto.Message):
    # The order ID associated with the market order (so they can match fill to
    # risk violation)
    order_id: str = betterproto.string_field(1)
    # The Asset code that the order was cancelled for
    asset: str = betterproto.string_field(2)
    # Whether the cancellation was intentional (i.e. the result of a cancellation
    # request by the user) or unintentional (e.g. due to a competitor going over
    # their risk limits)
    intentional: bool = betterproto.bool_field(3)
    # If not intentional, a message detailing why the cancellation took effect
    message: str = betterproto.string_field(4)
    # Timestamp that market order was *initiated*
    timestamp: str = betterproto.string_field(5)


@dataclass
class FeedMessage(betterproto.Message):
    """An update from the exchange"""

    request_failed_msg: "RequestFailedMessage" = betterproto.message_field(
        1, group="msg"
    )
    pnl_msg: "PnLMessage" = betterproto.message_field(2, group="msg")
    trade_msg: "TradeMessage" = betterproto.message_field(3, group="msg")
    fill_msg: "FillMessage" = betterproto.message_field(4, group="msg")
    market_snapshot_msg: "MarketSnapshotMessage" = betterproto.message_field(
        5, group="msg"
    )
    liquidation_msg: "LiquidationMessage" = betterproto.message_field(6, group="msg")
    generic_msg: "GenericMessage" = betterproto.message_field(7, group="msg")
    order_cancelled_msg: "OrderCancelledMessage" = betterproto.message_field(
        8, group="msg"
    )


@dataclass
class OrderSpec(betterproto.Message):
    """
    An order, as sent from the client to the server when placing or modifying
    and existing order
    """

    # The code of the asset to be traded
    asset: str = betterproto.string_field(1)
    # Whether the order is a market order or a limit order
    type: "OrderSpecType" = betterproto.enum_field(2)
    # Whether the order is a bid or an offer
    side: "OrderSpecSide" = betterproto.enum_field(3)
    # Quantity of the order
    quantity: int = betterproto.int32_field(4)
    # The price at which the order is set (only relevant for limit orders)
    price: str = betterproto.string_field(5)


@dataclass
class PlaceOrderRequest(betterproto.Message):
    """A request to place an order"""

    # The credentials of the relevant competitor
    creds: "Credentials" = betterproto.message_field(1)
    # The order to place
    order: "OrderSpec" = betterproto.message_field(2)


@dataclass
class PlaceOrderResponse(betterproto.Message):
    """A response to a request to place an order"""

    # Whether the request was successful (if false, the request failed and no
    # order was placed)
    ok: bool = betterproto.bool_field(1)
    # the ID of the order that was created
    order_id: str = betterproto.string_field(2)
    # Message about why the request to place an order may have failed
    message: str = betterproto.string_field(3)


@dataclass
class ModifyOrderRequest(betterproto.Message):
    """A request to modify an order"""

    # The credentials of the relevant competitor
    creds: "Credentials" = betterproto.message_field(1)
    # The id of the order to replace
    order_id: str = betterproto.string_field(2)
    # The order to replace the old one with
    new_order: "OrderSpec" = betterproto.message_field(3)


@dataclass
class ModifyOrderResponse(betterproto.Message):
    """A response to a ModifyOrderRequest"""

    # Whether the request was successful (if false, the request failed and no
    # order was removed or placed)
    ok: bool = betterproto.bool_field(1)
    # the ID of the order that was created
    order_id: str = betterproto.string_field(2)
    # Message about why the request to place an order may have failed
    message: str = betterproto.string_field(3)


@dataclass
class CancelOrderRequest(betterproto.Message):
    """A request to cancel an order"""

    # The credentials of the relevant competitor
    creds: "Credentials" = betterproto.message_field(1)
    # The id of the order to cancel
    order_id: str = betterproto.string_field(2)


@dataclass
class CancelOrderResponse(betterproto.Message):
    """A response to a CancelOrderRequest"""

    # Whether the request was successful (if false, the request failed and no
    # order was cancelled)
    ok: bool = betterproto.bool_field(1)
    # The message associated with the attempt to cancel an order
    message: str = betterproto.string_field(2)


class ExchangeServiceStub(betterproto.ServiceStub):
    """The gRPC Service"""

    async def register(
        self, *, creds: Optional["Credentials"] = None
    ) -> RegisterResponse:
        """Register a bot"""

        request = RegisterRequest()
        if creds is not None:
            request.creds = creds

        return await self._unary_unary(
            "/utc_bot.ExchangeService/Register",
            request,
            RegisterResponse,
        )

    async def stream_messages(
        self, *, creds: Optional["Credentials"] = None
    ) -> AsyncGenerator[FeedMessage, None]:
        """
        Request a stream of exchange updates, specifying what kinds of updates
        to include  N.B. only one of these streams may be open at a time, and
        they may only be  opened for a competitor who has registered
        """

        request = StreamMessagesRequest()
        if creds is not None:
            request.creds = creds

        async for response in self._unary_stream(
            "/utc_bot.ExchangeService/StreamMessages",
            request,
            FeedMessage,
        ):
            yield response

    async def await_trading_start(
        self, *, creds: Optional["Credentials"] = None
    ) -> AwaitTradingStartResponse:
        """Wait for trading to start"""

        request = AwaitTradingStartRequest()
        if creds is not None:
            request.creds = creds

        return await self._unary_unary(
            "/utc_bot.ExchangeService/AwaitTradingStart",
            request,
            AwaitTradingStartResponse,
        )

    async def place_order(
        self,
        *,
        creds: Optional["Credentials"] = None,
        order: Optional["OrderSpec"] = None,
    ) -> PlaceOrderResponse:
        """Place an order"""

        request = PlaceOrderRequest()
        if creds is not None:
            request.creds = creds
        if order is not None:
            request.order = order

        return await self._unary_unary(
            "/utc_bot.ExchangeService/PlaceOrder",
            request,
            PlaceOrderResponse,
        )

    async def modify_order(
        self,
        *,
        creds: Optional["Credentials"] = None,
        order_id: str = "",
        new_order: Optional["OrderSpec"] = None,
    ) -> ModifyOrderResponse:
        """Modify an order"""

        request = ModifyOrderRequest()
        if creds is not None:
            request.creds = creds
        request.order_id = order_id
        if new_order is not None:
            request.new_order = new_order

        return await self._unary_unary(
            "/utc_bot.ExchangeService/ModifyOrder",
            request,
            ModifyOrderResponse,
        )

    async def cancel_order(
        self, *, creds: Optional["Credentials"] = None, order_id: str = ""
    ) -> CancelOrderResponse:
        """Cancel an order"""

        request = CancelOrderRequest()
        if creds is not None:
            request.creds = creds
        request.order_id = order_id

        return await self._unary_unary(
            "/utc_bot.ExchangeService/CancelOrder",
            request,
            CancelOrderResponse,
        )
